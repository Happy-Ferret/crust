(*
-L /opt/rust/lib/rustlib/x86_64-unknown-linux-gnu/lib/
-A warnings
--crate-type lib
input.rs
 *)
module Compilation = struct
	let adt_of_tuple (tl : Types.mono_type list) = {
		Types.type_name = "__rust_tuple";
		Types.type_param = tl;
		Types.lifetime_param = [];
	  }
	let rec (adt_type_name : Types.mono_type -> string) = function
	  | `Adt_type a -> mangle_adt_name a
	  | `Ptr t | `Ref (_,t) -> (adt_type_name t) ^ "_ptr"
	  | `Ptr_Mut t | `Ref_Mut (_,t) -> "const_" ^ (adt_type_name t) ^ "_ptr"
	  | `Int _ -> "int"
	  | `UInt _ -> "uint"
	  | `Bool -> "int"
	  | `Unit -> "void"
	  | `Bottom -> failwith "No C representation"
	  | `Tuple tl -> mangle_adt_name @@ adt_of_tuple tl
	and mangle_adt_name t = 
	  if t.Types.type_param = [] then
		t.Types.type_name ^ "_t"
	  else
		t.Types.type_name ^ "_" ^
		  (String.concat "_" (List.map adt_type_name t.Types.type_param))
		  ^ "_t"
	and tuple_name tl = mangle_adt_name @@ adt_of_tuple tl

	let adt_of_inst (t_name,m_args) = 
	  {
		Types.type_name = t_name;
		Types.lifetime_param = [];
		Types.type_param = m_args
	  }

	let c_struct_name t = 
	  "__c_struct_" ^ (mangle_adt_name t)

	let mangle_fn_name fn_name mono_args = 
	  match mono_args with
	  | [] -> fn_name
	  | _ -> fn_name ^ (String.concat "_" (List.map adt_type_name mono_args))

	let struct_tag_field = "discr";;
	let arm_field = format_of_string "tag%d";;
	let field_label = format_of_string "field%d";;
	let tuple_field = field_label;;
	let data_field = "data";;

	let rec type_to_string : Types.mono_type -> string = function
	  | `Unit -> "void"
	  | `Bool -> "int"
	  | `UInt _ -> "unsigned"
	  | `Int _ -> "int"
	  | `Ptr t | `Ref (_,t) -> "const " ^ (type_to_string t) ^"*"
	  | `Ptr_Mut t | `Ref_Mut (_,t) -> (type_to_string t) ^ "*"
	  | `Bottom -> failwith "No C representation"
	  | `Tuple l -> tuple_name l
	  | `Adt_type a_type -> mangle_adt_name a_type

	let string_of_binop : Ir.bin_op -> string = function
	  | `BiAdd -> "+"
	  | `BiSub -> "-"
	  | `BiMul -> "*"
	  | `BiDiv -> "/"
	  | `BiRem -> "%"
	  | `BiAnd -> "&&"
	  | `BiOr -> "||"
	  | `BiBitXor -> "^"
	  | `BiBitAnd -> "&"
	  | `BiBitOr -> "|"
	  | `BiShl -> "<<"
	  | `BiShr -> ">>"
	  | `BiEq -> "=="
	  | `BiLt -> "<"
	  | `BiLe -> "<="
	  | `BiNe -> "!="
	  | `BiGe -> ">"
	  | `BiGt -> ">="

	let string_of_unop : Ir.un_op -> string = function
	  | `UnNot -> "!"
	  | `UnNeg -> "-"

	(* this is just lazy
	 * TODO: remove these
	 *)
	type r_type = Types.r_type
	type simple_type = Types.simple_type
	type lifetime = Types.lifetime
	let rec instrument_return = function
	  | `Unsafe (s,e) ->
		 `Unsafe (s,(instrument_return e))
	  | `Block (s,e) ->
		 `Block (s,(instrument_return e))
	  | `Return e -> `Return e
	  | e -> `Return e

	(* A note on t_simple_expr vs. simple_expr: t_simple_expr is a
	 * simple expression with the type of the expression, and
	  simple_expr is just the expression. With two exceptions
	  sub-expressions also have type information because type
	  information is easy to ignore and hard to recover (plus it makes
	  implementing sub-expression simplification MUCH
	  easier). Struct_Field and Assignment do not have type
	  information in some of their sub-terms because these sub-terms
	  can be generated by the simplification and this would require
	  recovering type information. In both cases (the referent and
	  lhs) the type information will almost certainly not be required
	  in later compilation stages so it's okay to throw it away *)
	type simple_expr = [
	  | `Struct_Field of simple_expr * string
	  | `Var of string
	  | `Literal of string
	  | `Deref of t_simple_expr
	  | `Address_of of t_simple_expr
	  | `Call of string * (lifetime list) * (r_type list) * (t_simple_expr list)
	  | `Return of t_simple_expr
	  | `Assignment of simple_expr * t_simple_expr
	  | `BinOp of Ir.bin_op * t_simple_expr * t_simple_expr
	  | `UnOp of Ir.un_op * t_simple_expr
	  | `Cast of t_simple_expr * r_type
	  ]
	 and t_simple_expr = r_type * simple_expr
	 and 'a complex_expr = [
	   | `Block of ('a stmt list) * 'a
	   | `Match of t_simple_expr * ('a match_arm list)
	   ]
	 and struct_fields = struct_field list
	 and struct_field = string * t_simple_expr (* field binding *)
	 and 'a stmt = [
	   | `Expr of 'a
	   | `Let of string * r_type * t_simple_expr
	   | `Declare of string * r_type
	   ]
	 (* this is a t_simple_expr but the type will always be `Bool actually *)
	and 'a match_arm = (t_simple_expr * 'a)
	type all_expr = r_type * [ all_expr complex_expr | simple_expr ]
	type all_complex = all_expr complex_expr

	(* TODO: For debugging, remove *)
	exception Break of all_expr
	let enum_field (enum : simple_expr) tag field = 
	  let data = `Struct_Field (enum,data_field) in
	  let tag_field = `Struct_Field (data,(Printf.sprintf arm_field tag)) in
	  let e_field = `Struct_Field (tag_field,(Printf.sprintf field_label field)) in
	  e_field
	let tag_field (enum: simple_expr) =
	  `Struct_Field (enum,struct_tag_field)
	let is_complex (_,e) = match e with
	  | #complex_expr -> true
	  | _ -> false

	let counter = ref 0;;
	let fresh_temp () = 
	  let new_id = !counter in
	  counter := !counter + 1;
	  Printf.sprintf "__temp_%d" new_id
	let trivial_expr = `Bool,(`Literal "1")

	let rec push_assignment (lhs : simple_expr) (e : all_expr) = 
	  match (snd e) with
	  | #simple_expr as s -> 
		 let assign = `Assignment (lhs,((fst e),s)) in
		 ((`Unit,assign) : all_expr)
	  | `Match (e,m_arms) ->
		 let m_arms' = List.map (fun (patt,m_arm) -> 
								 (patt,(push_assignment lhs m_arm))
								) m_arms in
		 (`Unit,`Match (e,m_arms'))
	  | `Block (s,e) -> (`Unit,(`Block (s,(push_assignment lhs e))))

	let lift_complex : all_expr complex_expr -> (string * all_expr) = fun expr ->
	  match expr with
	  | `Block (s,e)  ->
		 let out_var = fresh_temp () in
		 let e' = push_assignment (`Var out_var) e in
		 (out_var,(`Unit,`Block (s,e')))
	  | `Match (e,m_arms) ->
		 let out_var = fresh_temp () in
		 let m_arms' = List.map (fun (patt,m_arm) -> (patt,(push_assignment (`Var out_var) m_arm))) m_arms in
		 (out_var,(`Unit,`Match (e,m_arms')))

	let rec apply_lift_cb : 'a. Ir.expr -> (all_expr stmt list -> t_simple_expr -> 'a) -> 'a = 
	  fun expr cb ->
	  let expr' = simplify_ir expr in
	  let e_type = fst expr' in
	  match (snd expr') with
	  | #simple_expr as s -> cb [] (e_type,s)
	  | #all_complex as c ->
		 let (out_var,lifted) = lift_complex c in
		 let declaration = `Declare (out_var,e_type) in
		 let assign_block = `Expr lifted in
		 let replacement = e_type,(`Var out_var) in
		 cb [declaration ; assign_block] replacement
	and apply_lift e_type sub_expr cb =
	  apply_lift_cb sub_expr (fun stmt out_var -> 
							  let op = cb out_var in
							  match stmt with
							  | [] -> (e_type,op)
							  | _ -> 
								 let block_e = (e_type,op) in
								 let block = `Block (stmt,block_e) in
								 (e_type,block)
							 )
	and simplify_adt : 'a. r_type -> 'a list -> ?post:(t_simple_expr -> all_expr list) -> (t_simple_expr -> int -> 'a -> simple_expr) -> (int -> 'a -> Ir.expr) -> all_expr = fun e_type components ?(post=(fun _ -> [])) lhs rhs ->
	  let out_var = fresh_temp () in
	  let adt_var = e_type,`Var out_var in
	  let declare = `Declare (out_var,e_type) in
	  let stmts = List.mapi (fun i comp ->
							 let assign_lhs = lhs adt_var i comp in
							 let e = rhs i comp in
							 apply_lift_cb e (fun stmts e' ->
											  let assignment = `Assignment (assign_lhs,e') in
											  stmts @ [`Expr (`Unit,assignment)]
											 )
							) components in
	  let post_stmts = List.map (fun e -> `Expr e) (post adt_var) in
	  let stmts' = (declare :: (List.flatten stmts)) @ post_stmts in
	  (e_type,(`Block (stmts',adt_var)))
	and (simplify_ir : Ir.expr -> all_expr) = fun expr ->
	  match (snd expr) with
	  | `Call (f_name,l,t,args) ->
		 let (s,args') = List.fold_right 
							(fun arg (s_accum,arg_accum) ->
							 apply_lift_cb arg (fun stmt a -> (stmt @ s_accum,a::arg_accum))
							) args ([],[]) in
		 if s = [] then
		   (fst expr,`Call (f_name,l,t,args'))
		 else
		   (fst expr,`Block (s,(fst expr,`Call (f_name,l,t,args'))))
	  | `Address_of t -> 
		 apply_lift (fst expr) t (fun e -> `Address_of e)
	  | `Deref t -> 
		 apply_lift (fst expr) t (fun e -> `Deref e)
	  | `Var s -> (fst expr,(`Var s))
	  | `Literal s -> (fst expr,`Literal s)
	  | `Return r -> apply_lift (fst expr) r (fun e -> `Return e)
	  | `Struct_Field (s,f) -> apply_lift (fst expr) s (fun e -> `Struct_Field (snd e,f))
	  | `Tuple t_fields ->
		 let tuple_type = fst expr in
		 let lhs = fun adt_var f_index _ ->
		   `Struct_Field ((snd adt_var),(Printf.sprintf tuple_field f_index))
		 in
		 let rhs = fun _ f -> f in
		 simplify_adt tuple_type t_fields lhs rhs
	  | `Struct_Literal s_fields ->
		 let struct_type = fst expr in
		 let lhs = fun adt_var _ (f,_) ->
		   `Struct_Field (snd adt_var,f)
		 in
		 let rhs = fun _ (_,e) -> e in
		 simplify_adt struct_type s_fields lhs rhs
	  | `Enum_Literal (_,tag,exprs) ->
		 let lhs = fun adt_var f_index _ ->
		   enum_field (snd adt_var) tag f_index
		 in
		 let rhs = fun _ e -> e in
		 let post = fun adt_var ->
		   let tag_rhs = (`Int 4,(`Literal (string_of_int tag))) in
		   let discriminant_field = tag_field (snd adt_var) in
		   let assignment = `Assignment (discriminant_field,tag_rhs) in
		   [(`Unit,assignment)] in
		 simplify_adt (fst expr) exprs ~post:post lhs rhs
	  | `Unsafe (s,e) 
	  | `Block (s,e) ->
		 let b_type = fst e in
		 let stmt_frag  = List.flatten (List.map simplify_stmt s) in
		 apply_lift_cb e (fun stmt e' ->
						  let all_stmt = stmt_frag @ stmt in
						  let block = `Block (all_stmt,(e' :> all_expr)) in
						  (b_type,block))
	  | `Match (e,m_arms) -> 
		 let expr_type = (fst expr) in
		 apply_lift_cb e (fun stmt e' ->
						  let (stmt',match_on) = match (snd e') with
							| `Var _ -> stmt,e'
							| _ -> 
							   let matchee_name = fresh_temp () in
							   let matchee_type = fst e' in
							   let matchee_var = (matchee_type,`Var matchee_name) in
							   (stmt @ [ `Let (matchee_name,matchee_type,e') ],matchee_var)
						  in
						  let simpl_match = (expr_type,(simplify_match m_arms match_on)) in
						  if stmt' = [] then simpl_match 
						  else (expr_type,(`Block (stmt',simpl_match)))
						 )
(*		 apply_lift (fst expr) e (simplify_match m_arms)*)
	  | `UnOp (op,e) ->
		 apply_lift (fst expr) e (fun e' -> `UnOp (op,e'))
	  | `BinOp (op,e1,e2) ->
		 let expr_type = (fst expr) in
		 simplify_binary e1 e2 (fun e1' e2' ->
								expr_type,(`BinOp (op,e1',e2'))
							   )
	  | `Assignment (e1,e2) ->
		 simplify_binary e1 e2 (fun t_e1 e2' ->
								let e1' = snd t_e1 in
								`Unit,(`Assignment (e1',e2'))
							   )
	  | `Cast (e,t) ->
		 apply_lift (fst expr) e (fun e' -> `Cast (e',t))
	and simplify_binary e1 e2 cb = 
	  apply_lift_cb e1 (fun stmt1 e1' ->
						apply_lift_cb e2 (fun stmt2 e2' ->
										  let stmts = stmt1 @ stmt2 in
										  let b_op = cb e1' e2' in
										  let b_type = fst b_op in
										  if stmts = [] then b_op
										  else b_type,`Block (stmts,b_op)
										 )
					   )
	and simplify_stmt : Ir.stmt -> all_expr stmt list = function
	  | `Let (v_name,v_type,expr) ->
		 let expr' = simplify_ir expr in
		 let e_type = fst expr' in
		 begin
		   match (snd expr') with
		   | #simple_expr as s -> [`Let (v_name,v_type,(e_type,s))]
		   | #complex_expr as c -> 
			  let c' = push_assignment (`Var v_name) (e_type,c) in
			  [`Declare (v_name,v_type); `Expr c']
		 end
	  | `Expr e ->
		 let e' = simplify_ir e in
		 [`Expr e']
	and simplify_match : Ir.match_arm list -> t_simple_expr -> 'a = 
	  fun m_arms t_matchee -> 
	  let matchee = snd t_matchee in
	  let m_arms' = List.map (simplify_match_arm matchee) m_arms in
	  `Match (t_matchee,m_arms')
	and simplify_match_arm matchee (patt,m_arm) = 
	  let simpl_m_arm = simplify_ir m_arm in
	  let (predicates,bindings) = compile_pattern ([],[]) matchee patt in
	  let predicate_expr = List.fold_right (fun (lhs,rhs) accum ->
											let comp = (`Bool,(`BinOp (`BiEq,lhs,rhs))) in
											`Bool,(`BinOp (`BiAnd,comp,accum))
										   ) predicates trivial_expr
	  in
	  let assignments = List.map (fun (bind_type,bind_name,matchee) ->
								  let rhs = bind_type,matchee in
								  `Let (bind_name,bind_type,rhs)
								 ) bindings
	  in
	  let final_expr = match assignments with
		| [] -> simpl_m_arm
		| _ -> begin
			match (snd simpl_m_arm) with
			| `Block (s,m_e) -> (fst simpl_m_arm),`Block ((assignments @ s),m_e)
			| _ -> (fst simpl_m_arm),`Block (assignments,simpl_m_arm)
		  end
	  in
	  (predicate_expr,final_expr)
	and compile_pattern = fun (predicates,bindings) matchee patt ->
	  match patt with
	  | `Wild -> predicates,bindings
	  | `Bind (b_type,b_name) ->
		 (predicates,(b_type,b_name,matchee)::bindings)
	  | `Enum (e_type,_,tag,patts) -> 
		 let fields = List.mapi (fun i _ -> enum_field matchee tag i) patts in
		 let (predicates',bindings') = List.fold_left2 compile_pattern (predicates,bindings) fields patts in
		 let tag_rhs = (`Int 4,tag_field matchee) in
		 let tag_lhs = (`Int 4,`Literal (string_of_int tag)) in
		 (tag_lhs,tag_rhs)::predicates',bindings'
	  | `Literal (l_type,l) ->
		 let lhs = ((l_type :> Types.r_type),`Literal l) in
		 let rhs = ((l_type :> Types.r_type),matchee) in
		 (lhs,rhs)::predicates,bindings

(*	let compile_fn_inst (f_name,mono_args) = 
	  let fn_def = Hashtbl.find fn_env f_name in
	  let bindings = List.map2 (fun t_name t_val -> (t_name,t_val)) fn_def.fn_tparams mono_args in
	  let f_name = mangle_fn_name fn_def.fn_name mono_args in
	  let buf = Buffer.create 100 in
	  let ret_type = to_monomorph bindings fn_def.ref_type in
	  Buffer.add_string buf (string_of_type (ret_type));
	  Buffer.add_string buf " ";
	  Buffer.add_string buf f_name;
	  Buffer.add_string buf "(";
	  let dump_arg (arg_name, arg_type) = 
		Buffer.add_string buf (string_of_type (to_monomorph bindings arg_type));
		Buffer.add_string buf " ";
		Buffer.add_string buf arg_name
	  in
	  let rec arg_dump_loop = function ->
									 | [] -> ()
									 | a::[] -> dump_arg a
									 | h::t -> dump_arg h; Buffer.add_string buf ","; arg_dump_loop t
	  in
	  arg_dump_loop fn_def.fn_args;
	  Buffer.add_string buf "{\n";
	  let to_compile = 
		if ret_type = `Unit then 
		  fn_def.fn_body 
		else 
		  instrument_return fn_def.fn_body
	  in
	  compile_expr buf bindings 1 to_compile;
	  Buffer.add_string buf "}\n";
	  *)

	let pp_t _ = ""

	class emitter buf = 
	object(self)
	  val mutable indent_level = 0
	  method private put s =
		Buffer.add_string buf s
	end
	class typedef_emitter buf = 
	  object (self)
		inherit emitter buf
		method private bindings t_vars bindings = 
		  List.map2 (fun t_name m_type -> (t_name,m_type)) t_vars bindings
		method dump_type_instantiation (type_name,mono_args) = 
		  let c_name = c_struct_name @@ adt_of_inst (type_name,mono_args) in
		  self#put @@ "struct " ^ c_name ^ " { // " ^ (pp_t (type_name,mono_args)) ^ "\n";
		  if type_name = "__rust_tuple" then
			self#dump_tuple mono_args
		  else begin
			  let t_def = Hashtbl.find Env.adt_env type_name in
			  match t_def with
			  | `Enum_def d -> 
				 let t_binding = self#bindings d.Ir.e_tparam mono_args in
				 self#dump_enum t_binding d
			  | `Struct_def s ->
				 let t_binding = self#bindings s.Ir.s_tparam mono_args in
				 self#dump_struct t_binding s
			end
		method private dump_tuple mono_args = 
		  let field_names = List.mapi (fun i _ -> Printf.sprintf tuple_field i) mono_args in
		  let fields = List.map2 (fun f_name f_type -> 
								  (f_name,f_type)
								 ) field_names mono_args in
		  self#dump_fields fields
		method private dump_struct t_binding (s : Ir.struct_def) =
		  self#dump_fields @@ self#monomorphize_fields t_binding s.Ir.struct_fields
		method private dump_enum t_binding enum = 
		  self#dump_field_def (struct_tag_field,`Int 32);
		  let has_data = List.exists (fun v -> 
									  v.Ir.variant_fields <> []) 
									 enum.Ir.variants
		  in
		  if has_data then begin
			  self#put "union {\n";
			  List.iteri (self#dump_variant t_binding) enum.Ir.variants;
			  self#put "} data;\n"
			end
		  else ();
		  self#put "};"
		method private dump_variant t_binding tag v = 
		  if v.Ir.variant_fields = [] then ()
		  else begin
			  let m_args = List.map (Types.to_monomorph t_binding) v.Ir.variant_fields in
			  self#put "struct {\n";
			  self#dump_tuple m_args;
			  self#put "} ";
			  self#put @@ Printf.sprintf arm_field tag;
			  self#put ";\n"
			end
			
		method private dump_field_def ((field_name,field_type) : string * Types.mono_type) = 
		  self#put (type_to_string field_type);
		  self#put " ";
		  self#put field_name;
		  self#put ";\n"
		method private monomorphize_fields t_binding f_def = 
		  List.map (self#monomorph_field t_binding) f_def
		method private monomorph_field t_binding (f_name,f_type) = 
		  (f_name,(Types.to_monomorph t_binding f_type))
		method private dump_fields : ((string * Types.mono_type) list) -> unit = List.iter self#dump_field_def
	  end

	class expr_emitter buf t_bindings = 
	object (self)
	  inherit emitter buf
	  method private t_string (t : r_type) = 
		type_to_string (Types.to_monomorph t_bindings t)
	  method dump_expr (expr : all_expr) = 
		match (snd expr) with
		| `Block (s,e) ->
		   Buffer.add_string buf "{\n";
		   List.iter self#dump_stmt s;
		   self#dump_expr e;
		   Buffer.add_string buf ";\n}\n";
		| `Match (_,m_arm) ->
		   self#dump_match m_arm
		| #simple_expr as s -> self#dump_simple_expr s
	  method dump_simple_expr = function
		| `Var s -> Buffer.add_string buf s
		| `Literal l -> Buffer.add_string buf l
		| `Deref (_,e) -> 
		   self#put "*";
		   self#dump_simple_expr e
		| `Address_of (_,e) ->
		   self#put "&";
		   self#dump_simple_expr e
		| `Return (_,e) ->
		   self#put "return ";
		   self#dump_simple_expr e
		| `Assignment (lhs,(_,rhs)) ->
		   self#dump_simple_expr lhs;
		   self#put " = ";
		   self#dump_simple_expr rhs
		| `Cast ((_,expr),t) ->
		   self#put @@ Printf.sprintf "(%s)" @@ self#t_string t;
		   self#dump_simple_expr expr
		| `Struct_Field (s,f) ->
		   self#dump_simple_expr s;
		   self#put ".";
		   self#put f
		| `Call (fn_name,_,inst,args) ->
		   let m_args = List.map (Types.to_monomorph t_bindings) inst in
		   let mangled_fname = mangle_fn_name fn_name m_args in
		   Buffer.add_string buf mangled_fname;
		   Buffer.add_string buf "(";
		   self#dump_args args;
		   Buffer.add_string buf ")"
		| `BinOp (op,(_,rhs),(_,lhs)) ->
		   self#put "(";
		   self#dump_simple_expr rhs;
		   self#put " ";
		   self#put @@ string_of_binop op;
		   self#put " ";
		   self#dump_simple_expr lhs;
		   self#put ")"
		| `UnOp (op,(_,e)) ->
		   self#put "(";
		   self#put @@ string_of_unop op;
		   self#dump_simple_expr e;
		   self#put ")"
	  method dump_match = function
		| (match_condition,match_body)::t -> 
		   Buffer.add_string buf "if(";
		   self#dump_expr (match_condition :> all_expr);
		   Buffer.add_string buf ")\n";
		   self#dump_expr match_body;
		   self#dump_match_rest t
		| _ -> assert false
	  method dump_match_rest = function
		| [] -> ()
		| (match_condition,match_body)::t -> 
		   Buffer.add_string buf "else if(";
		   self#dump_expr (match_condition :> all_expr);
		   Buffer.add_string buf ")";
		   self#dump_expr match_body;
		   self#dump_match_rest t
	  method dump_stmt = function
		| `Let (v_name,r_type,expr) ->
		   let m_type = Types.to_monomorph t_bindings r_type in
		   let type_string = type_to_string m_type in
		   Buffer.add_string buf (Printf.sprintf "%s %s = " type_string v_name);
		   self#dump_expr (expr :> all_expr);
		   Buffer.add_string buf ";\n"
		| `Declare (v_name,r_type) ->
		   let m_type = Types.to_monomorph t_bindings r_type in
		   let type_string = type_to_string m_type in
		   Buffer.add_string buf (Printf.sprintf "%s %s;\n" type_string v_name)
		| `Expr ((_,`Block _) as e) ->
		   self#dump_expr e;
		| `Expr ((_,`Match _) as e)->
		   self#dump_expr e;
		| `Expr e ->
		   self#dump_expr e;
		   self#put ";\n"
	  method dump_args = function
		| (_,e)::t -> 
		   self#dump_simple_expr e;
		   self#dump_args_rest t
		| [] -> ()
	  method dump_args_rest = function
		| [] -> ()
		| (_,e)::t ->
		   self#put ", ";
		   self#dump_simple_expr e;
		   self#dump_args_rest t
	end		 

	let int_type = `Int 4;;
	let dummy_enum = `Bottom;;
	let test_type = `Enum_def {
		Ir.enum_name = "option";
		Ir.e_lifetime_param = [];
		Ir.e_tparam = [];
		Ir.variants = [
			{
			  Ir.variant_name = "foo";
			  Ir.variant_fields = [ `Int 32; `Bool; `Adt_type { Types.type_name = "__rust_tuple"; Types.type_param = [ `Int 32; `Bool ]; Types.lifetime_param = [] } ];
			};
			{
			  Ir.variant_name = "baz";
			  Ir.variant_fields = []
			};
			{
			  Ir.variant_name = "bar";
			  Ir.variant_fields = [ `UInt 32 ];
			}
		  ];
		Ir.drop_fn = None
	  };;
	let _ = Hashtbl.add Env.adt_env "option" test_type;;
	let enum_type = { Types.type_name = "foo"; Types.lifetime_param = []; Types.type_param = [] };;
	let enum_type_2 = { Types.type_name = "foo"; Types.lifetime_param = []; Types.type_param = [] };;
	let test_match : Ir.expr = `Bottom,`Return (int_type,(`Match ((int_type,`Block ([],(int_type,`Var "foo"))),[
										 (`Enum (enum_type,"",3,[
																`Wild;
																`Literal (int_type,"3");
																`Enum (enum_type_2,"",2,[`Bind (int_type,"a");`Bind (int_type,"b")])
 															  ])),(int_type,`BinOp (`BiAdd,(int_type,`Var "a"),(int_type,`Var "b")));
										 `Wild,((`Tuple [int_type;int_type]),`Tuple [(int_type,`Var "foo");(int_type,`Literal "44")])
									   ])));;
	let test_ast = (`Bottom,`Return (`Ref ("f",`Int 3),`Address_of ((`Int 3,`Block ([],(`Int 3,`Var "foo"))))));;
	let do_test () = simplify_ir test_ast;;
	let do_test_2 () = 
	  let ir = simplify_ir test_match in
	  let buf = Buffer.create 1000 in
	  let emitter = new expr_emitter buf [] in
	  emitter#dump_expr ir;
	  print_endline (Buffer.contents buf);
	  Buffer.clear buf;
	  let t_dump = new typedef_emitter buf in
	  t_dump#dump_type_instantiation ("option",[]);
	  print_endline (Buffer.contents buf)
end

let _ = Compilation.do_test_2 ()
