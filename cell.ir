# Syntax consists of whitespace-separated words.  Characters "()[]{}<>:;" are
# for human readability ONLY - for parsing, treat them like whitespace.
# Variable-length structures are prefixed with the number of elements.
#
# Type variables are prefixed with 'var' (when used).  struct/enum type names
# are unprefixed.  Lifetimes and ordinary variables are unprefixed because they
# don't share a namespace with anything else.

# 'Cell' has zero lifetime parameters and one type parameter.  The type
# parameter is named T.
struct Cell<0><1: T>
# Cell has one field.
{1
    # Field name + type.  The type is UnsafeCell which takes 0 lifetime
    # parameters and 1 type parameter.  The type parameter is instantiated with
    # the type variable 'T'.
    value: UnsafeCell<0><1: var T>
}

fn Cell_new<0><1: T>
    args (1: value: var T)
    return Cell<0><1: var T>
    body
        struct_literal Cell<0><1: var T>
        {1
            # Initialize 'value' with 'UnsafeCell::new::<T>(value)
            value: call UnsafeCell_new<0><1: var T>(1: var value)
        }

struct UnsafeCell<0><1: T>
{1
    value: var T
}

fn UnsafeCell_new<0><1: T>
    args (1: value: var T)
    return UnsafeCell<0><1: var T>
    body struct_literal UnsafeCell<0><1: var T> {1 value: var value}

# Notation:
#
# Quoted strings denote literal words.
#
# "*" denotes zero or more copies.  The actual list of items will be prefixed
# with the number of items present.
#   
# Words in parentheses are used to distinguish different uses of the same
# syntactic class.  For example, a struct definition contains a name and two
# lists of names.  These are written "name(struct)", "name(lifetime_param)",
# and "name(type_param)" to indicate the purpose of each "name".

# Syntax:
#   word: any sequence of letters, underscores, and/or digits
#
#   type ::= "var" name
#          | "adt" name(struct_or_enum) lifetime* type*
#          | "tuple" type*
#          | "ref" lifetime type
#          | "ref_mut" lifetime type
#          | "ptr" type
#          | "ptr_mut" type
#          | "str"
#          | "vec" type
#          | "fixed_vec" word(len) type
#          | "int" word(bits|"size")
#          | "uint" word(bits|"size")
#          | "float" word(bits)
#          | "bool"
#          | "char"
#          | "fn"
#          | "unit"
#          | "bottom"
#          | "abstract" name lifetime* type*
#   lifetime ::= name
#   name ::= word
#
#   abstract_type_def ::= "abstract_type" name name(lifetime_param)* name(type_param)*
#   associated_type_def ::= "associated_type" name(lifetime_param)* name(type_param)*
#                               name lifetimes* types* type(result)
#
#   struct_def ::= "struct" name(struct) name(lifetime_param)* name(type_param)* field_def* name(drop_fn)?
#   field_def ::= name(field) type
#
#   enum_def ::= "enum" name name(lifetime_param)* name(type_params)* variant_def* name(drop_fn)?
#   variant_def ::= name(variant) type*
#
#   fn_def ::= "fn" name(fn) name(lifetime_param)* name(type_param)*
#                   "args" arg_decl*  "return" type
#                   [ "impl" name(abstract_fn) lifetime(trait_args)* type(self_plus_trait_args)* ]?
#                   "body" expr
#   abstract_fn_def ::= "abstract_fn" name(fn) name(lifetime_param)* name(type_param)*
#                       "args" arg_decl*  "return" type
#   extern_fn_def ::= "extern_fn" abi name(fn) name(lifetime_param)* name(type_param)*
#                       "args" arg_decl*  "return" type
#   arg_decl ::= pattern(arg)       # "pattern" already contains the type
#
#   expr ::= type expr_variant
#   expr_variant ::= "var" name
#                  | "const" name
#                  | "simple_literal" word
#                  | "struct_literal" field*
#                  | "enum_literal" name(variant) word(variant_index) expr*
#                  | "tuple_literal" expr*
#                  | "match" expr match_arm*
#                  | "block" stmt* expr
#                  | "field" expr(struct) name(field)
#                  | "deref" expr
#                  | "addr_of" expr
#                  | "index" expr expr
#                  | "range" expr? expr?
#                  | "cast" expr type
#                  | "binop" op expr expr
#                  | "unop" op expr expr
#                  | "call" name(fn) lifetime* type* expr(arg)*
#                  | "unsafe" stmt* expr
#                  | "assign" expr expr
#				   | "return" expr
#                  | "assign_op" op expr expr
#                  | "while" expr expr
#                  | "vec" expr*
#	binop ::= BiAdd | ...
#	unop ::= ...
#   field ::= name(field) expr
#
#   match_arm ::= pattern expr
#   pattern ::= type pattern_variant
#   pattern_variant ::= "var" name
#                     | "const" name
#                     | "enum" name(variant) word(variant_index) pattern*
#                     | "wild"
#                     | "simple_literal" word
#                     | "tuple" pat*
#                     | "ref_var" name
#                     | "addr_of" pat
#
#   stmt ::= "expr" expr
#          | "let" pattern expr?    # "pattern" already contains the type
#
#   const_def ::= "const" name ty expr
#
#   static_def ::= "static" name ty expr
